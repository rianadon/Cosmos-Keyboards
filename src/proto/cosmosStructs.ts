/** Cosmos-Specific encoding schemas. Helpers are at the bottom */

import { PART_INFO, socketSize } from '$lib/geometry/socketsParts'
import { objEntries, objKeys } from '$lib/worker/util'
import { writeFileSync } from 'node:fs'
import { join } from 'node:path'
import { fileURLToPath } from 'node:url'

let code = '// Autogenerated from cosmosStructs.ts\n\n' // Needed for later
let enums: Record<string, { max: number }> = {} // Also needed for later

enumeration('PART', {
  // Things that get placed a lot in the model.
  0: null, // Special type for inheriting the global type
  1: 'mx-better',
  2: 'mx-pcb',
  3: 'mx-pcb-twist',
  4: 'mx-hotswap',
  5: 'alps',
  6: 'choc',
  7: 'choc-hotswap',
  8: 'blank',
  9: 'mx-klavgen',

  // You wouldn't put many of these on a keyboard.
  16: 'ec11',
  17: 'oled-128x32-0.91in-adafruit',
  18: 'oled-128x32-0.91in-dfrobot',
  19: 'evqwgd001',
  20: 'joystick-joycon-adafruit',
  21: 'joystick-ps2-40x45',
  22: 'trackball',
  23: 'trackpad-cirque',
  24: 'oled-128x32-0.91in-spi-adafruit',

  // Old stuff no one should be using.
  110: 'old-mx',
  111: 'old-box',
  112: 'old-mx-hotswap',
  113: 'old-mx-hotswap',
  114: 'old-mx-snap-in',
  115: 'old-mx-snap-in-hotswap',
})

enumeration('PROFILE', [null, 'xda', 'dsa', 'choc', 'sa', 'mt3', 'oem', 'des', 'cherry', 'ma'])
enumeration('HOMING', [null, 'thumb', 'index', 'middle', 'ring', 'pinky'])

// These two are deprecated
enumeration('CONNECTOR_TYPE', [null, 'usb', 'trrs'])
enumeration('CONNECTOR_SIZE', ['slim', 'average', 'big'])

enumeration('CONNECTOR_PRESET', ['custom', 'usb-slim', 'usb-average', 'usb-big', 'trrs'], true)

enumeration('SCREW_TYPE', ['screw insert', 'tapered screw insert', 'expanding screw insert', 'tapped hole'])
enumeration('SCREW_SIZE', ['M3', 'M4', '#4-40', '#6-32'])

enumeration('CLUSTER_TYPE', ['matrix', 'sphere'])
enumeration('CLUSTER_NAME', ['fingers', 'thumbs'])
enumeration('CLUSTER_SIDE', ['right', 'left'])

enumeration('MICROCONTROLLER_NAME', [
  null,
  'pi-pico',
  'promicro',
  'promicro-usb-c',
  'itsybitsy-adafruit',
  'itsybitsy-adafruit-nrf52840',
  'kb2040-adafruit',
  'rp2040-black-usb-c-aliexpress',
  'nrfmicro-or-nicenano',
  'seeed-studio-xiao',
  'seeed-studio-xiao-nrf52840',
  'waveshare-rp2040-zero',
  'weact-studio-ch552t',
  'feather-rp2040-adafruit',
  'cyboard-assimilator',
])

struct('PartVariant', {
  part: 'PART,7',
  aspect: 'int,8',
  variant: 'int,6',
})

struct('Keycap', {
  profile: 'PROFILE,4',
  row: 'int,3',
  letter: 'int,8',
  home: 'HOMING,3',
})

struct('Connector', {
  connector: 'CONNECTOR_TYPE,3',
  connectorSizeUSB: 'CONNECTOR_SIZE,3',
})

struct('ScrewFlags', {
  clearScrews: 'bool,1',
  screwCountersink: 'bool,1',
  screwSize: 'SCREW_SIZE,3',
  screwType: 'SCREW_TYPE,2',
})

struct('ClusterFlags', {
  side: 'CLUSTER_SIDE,1',
  name: 'CLUSTER_NAME,2',
  type: 'CLUSTER_TYPE,2',
})

struct('Microcontroller', {
  microcontroller: 'MICROCONTROLLER_NAME,6',
  fastenMicrocontroller: 'bool,1',
})

struct('RoundedFlags', { side: 'bool,1', top: 'bool,1' })
struct('KeyboardFlags', { wrEnable: 'bool,1', unibody: 'bool,1', noMirrorConnectors: 'bool,1' })
struct('BasicShellFlags', { lip: 'bool,1' })
struct('StiltsShellFlags', { inside: 'bool,1' })
struct('TiltShellFlags', { usePattern: 'bool,1' })

// ----------------------------------------------------------------------------
//                      UTILITIES FOR CODE GEN
//                    no need to edit this stuff
// ----------------------------------------------------------------------------

function capitalize(name: string) {
  return name.split(/[_-]/).map(s => s[0].toUpperCase() + s.substring(1).toLowerCase()).join('')
}

function enumeration<T extends string | null>(name: string, fields: Record<number, T> | T[], writeTransformers = false) {
  if (name.toUpperCase() != name) throw new Error('Enum name must be upercase')
  code += `export const ${name} = ${JSON.stringify(fields).replace(/"(\d+)":/g, '$1:')} as const\n`
  enums[name] = { max: Math.max(...Object.keys(fields).map(Number)) }
  if (Array.isArray(fields)) {
    code += `export type ${capitalize(name)} = typeof ${name}[number]\n`
  } else {
    code += `export type ${capitalize(name)} = typeof ${name}[keyof typeof ${name}]\n`
  }
  if (writeTransformers) {
    code += `export function encode${capitalize(name)}(x: ${capitalize(name)}) { return calcId(${name}, x, '/enum ${name}')}\n`
    code += `export function decode${capitalize(name)}(x: number): ${capitalize(name)} { return lookup(${name}, x, '/enum ${name}')}\n`
  }
}

function struct(name: string, fields: Record<string, string>) {
  if (name[0].toUpperCase() != name[0]) throw new Error('Struct name must be capitalized')
  const fType = (v: string) => ({ int: 'number', bool: 'boolean' })[v.split(',')[0]] || capitalize(v.split(',')[0])
  code += `export interface ${name} {${Object.entries(fields).map(([k, v]) => k + ':' + fType(v)).join(';')}}\n`
  // Create the encoder and decoders
  let offset = 0
  const factors: string[] = [] // For encoder
  const props: string[] = [] // For decoder
  for (const [k, v] of Object.entries(fields)) {
    const [type, bits] = v.split(',')
    const dec = `(x >> ${offset}) & ${(1 << Number(bits)) - 1}` // Decoded field

    if (type == 'int') {
      factors.push(`(checkInt(x.${k}, ${bits}, '${k} in ${name}') << ${offset})`)
      props.push(`${k}: ${dec}`)
    } else if (type == 'bool') {
      factors.push(`((x.${k} ? 1 : 0) << ${offset})`)
      props.push(`${k}: Boolean(${dec})`)
    } else {
      if (!enums[type]) throw new Error(`Enum ${type} does not exist. Is it defined before this struct?`)
      if ((1 << Number(bits)) - 1 < enums[type].max) throw new Error(`Enum ${type} is too large for ${bits} bits`)
      factors.push(`(calcId(${type}, x.${k}, '${k} in ${name}') << ${offset})`)
      props.push(`${k}: lookup(${type}, ${dec}, '${k} in ${name}')`)
    }
    offset += Number(bits)
  }
  code += `export function encode${name}(x: ${name}) { return ${factors.join('|')} }\n`
  code += `export function decode${name}(x: number): ${name} { return { ${props.join(',')} } }\n`
}

code += `\n\nfunction lookup<E>(items: readonly E[] | Record<number, E>, id: number, msg: string) {
  if (typeof items[id] == 'undefined') throw new Error(\`Invalid id \${id} for field \${msg}\`)
  return items[id]
}
function calcId<E>(items: readonly E[] | Record<number, E>, e: E, msg: string) {
  if (Array.isArray(items)) {
    const idx = items.indexOf(e)
    if (idx >= 0) return idx
  } else {
    const ent = Object.entries(items).find(([k,v]) => v == e)
    if (ent) return Number(ent[0])
  }
  throw new Error(\`Invalid value \${e} for field \${msg}\`)
}
function checkInt(x: number, bits: number, msg: string) {
  if (x < 0 || x >= (1 << bits)) throw new Error(\`Integer \${x} for field \${msg} is out of bounds\`)
  return x
}

import type { CuttleBaseKey, Keycap as IKeycap } from '../src/lib/worker/config'
`

const safeCaps = (s: string) => capitalize(s).replace(/\W/g, '_')

for (const [part, info] of objEntries(PART_INFO)) {
  if (part == 'blank') { // Special interface for blank keys
    code += "export interface CuttleBlankKey extends CuttleBaseKey { type: 'blank', keycap?: IKeycap, size: { width: number; height: number } }\n"
    continue
  }
  if ('variants' in info) {
    const body = Object.entries(info.variants).map(([k, v]) => k + ':' + v.map(i => JSON.stringify(i)).join('|')).join(',')
    code += `export type ${safeCaps(part)}Variant = {${body}}\n`
  }
  code += `export interface Cuttle${safeCaps(part)}Key extends CuttleBaseKey { type: '${part}',`
  if ('variants' in info) code += `variant: ${safeCaps(part)}Variant,`
  if (PART_INFO[part].keycap) code += 'keycap: IKeycap,'
  if ('radius' in socketSize({ type: part, variant: {} } as any)) code += 'size?: { sides: number },'
  code += '}\n'
}
code += 'export type CuttleKey = ' + objKeys(PART_INFO).map(p => `Cuttle${safeCaps(p)}Key`).join('|') + '\n'

const targetDir = fileURLToPath(new URL('../../target', import.meta.url))
writeFileSync(join(targetDir, 'cosmosStructs.ts'), code)
